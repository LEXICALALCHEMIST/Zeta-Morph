

Current File Structure
ZetaMorph/
  MorphLogic/
    SkeletonInitializer.js (Initializes 12-unit skeletons, handles snapshot resets)
    PushModule.js (Applies push operations using shifted keys)
    PullModule.js
    SnapshotPush.js (Handles snapshot resets for push operations)
    SnapshotPull.js (Handles snapshot resets for push operations)
    PullModule.js (Handles subtraction)
  core/
    SacredSymbols.js (Defines SYMBOL_SEQUENCE and VOID_SYMBOL)
    carryBus.js (Manages carry operations, used by SkeletonInitializer.js)
    MorphInit.js (Sets up ecosystem by initializing skeleton and shifting keys)
  key/
    KeyMaker.js (Generates keys for numbers)
    ShiftKey.js (Shifts keys to match target lengths)
  skeleton/
    unitExtensionsPull.js
    unitExtensionsPush.js (Extends unit classes with push logic)
    unit1.js to unit12.js (Individual unit classes for skeleton initialization)
  test/
    testSkeletonInit.js (Tests skeleton initialization for 999,999,999,999)
    testKeyMaker.js (Tests key generation for 333, 303,303, 999,999,999, 777,777,888,999)
    testShiftKey.js (Tests key shifting for the same numbers)
    testMorphInit.js (Tests ecosystem setup: skeleton=500, key=50)
    testPush.js (Tests pushing 50 onto 500, expecting 550)

  Notes on the Structure
Minimal Setup: We’ve kept the system minimal, focusing on skeleton initialization, key generation/shifting, ecosystem setup, and push operations. Pull operations (unitExtensionsPull.js, PullModule.js, SnapshotPull.js) and distributed mesh components (Chronos OS, Neurum Protocol, ZTRL) are not yet implemented.
12 Units: The system uses 12 units (Unit1–Unit12), with individual files (unit1.js to unit12.js) for modularity, as seen in testSkeletonInit.js.
Symbolic Processing: Keys (KeyMaker.js, ShiftKey.js) and skeletons (SkeletonInitializer.js) use symbolic representations, aligning with ZetaMorph’s core principle of symbolic math.
Push Ready: We’ve implemented push logic (unitExtensionsPush.js, PushModule.js, Snapshot.js), ready to test in testPush.js.


CORE////----------------------------------------------------------


------------------------------------------------------------------
carryBus.js
------------------------------------------------------------------
export default class CarryBus {
  constructor() {
    this.carryValue = 0;
    this.carryTarget = null;
  }

  registerCarry(value, target) {
    this.carryValue = value;
    this.carryTarget = target;
    console.log(`CarryBus: Registered CARRY: ${value} to ${target}`);
  }

  flushCarry() {
    const carry = { carryValue: this.carryValue, carryTarget: this.carryTarget };
    console.log(`CarryBus: Flushed CARRY: ${this.carryValue} to ${this.carryTarget}`);
    this.carryValue = 0;
    this.carryTarget = null;
    return carry;
  }
}



------------------------------------------------------------------
MorphInit.js
------------------------------------------------------------------
import SkeletonInitializer from '../MorphLogic/SkeletonInitializer.js';
import KeyMaker from '../key/KeyMaker.js';
import ShiftKey from '../key/ShiftKey.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from './SacredSymbols.js';

export async function morphInit(newNumber, currentSkeletonNumber, isPushOperation = true) {
  console.log(`morphInit(${newNumber}, ${currentSkeletonNumber})`);
  
  const newNumberLength = newNumber.toString().length;
  const currentSkeletonLength = currentSkeletonNumber.toString().length;
  
  let setNumber, keyNumber;
  
  // Compare lengths to decide skeleton and key
  if (newNumberLength > currentSkeletonLength) {
    setNumber = newNumber; // Larger number for skeleton
    keyNumber = currentSkeletonNumber; // Smaller number for key
  } else {
    setNumber = currentSkeletonNumber; // Keep current skeleton
    keyNumber = newNumber; // New number for key
  }
  
  // Set skeleton
  const skeleton = new SkeletonInitializer();
  await skeleton.set(setNumber, isPushOperation);
  
  // Ensure numberLength is set
  if (!skeleton.state.numberLength) {
    console.warn(`Warning: skeleton.state.numberLength undefined, setting to ${setNumber.toString().length}`);
    skeleton.state.numberLength = setNumber.toString().length;
  }
  
  // Generate and shift key
  const keyMaker = new KeyMaker();
  const tempKey = keyMaker.makeKey(keyNumber);
  const shiftKey = new ShiftKey();
  const shiftedKey = shiftKey.shift(tempKey, skeleton.state.numberLength);
  
  // Log results
  const skeletonState = skeleton.getState();
  const skeletonDisplay = `<${skeletonState.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${skeletonState.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${skeletonState.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
  console.log(`morphInit: ${newNumber} length ${newNumberLength}, ${currentSkeletonNumber} length ${currentSkeletonLength}: if current is < new number ${newNumber}, set skeleton for: ${setNumber}, genKEY for: ${keyNumber}, new skeleton: ${skeletonDisplay}, new key: ${JSON.stringify(shiftedKey)}`);
  
  return { skeleton, key: shiftedKey };
}



------------------------------------------------------------------
SacredSymbols.js
------------------------------------------------------------------
export const SYMBOL_SEQUENCE = [
    '⚙', '●', '○', '□', '¤', '■', '•', '¥', '◇', '▲', '♤'
  ];
  
  export const VOID_SYMBOL = '⊙';
  
  console.log('Exporting VOID_SYMBOL:', VOID_SYMBOL);


KEY////----------------------------------------------------------
------------------------------------------------------------------
keyMaker.js
------------------------------------------------------------------
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export default class KeyMaker {
  makeKey(number) {
    console.log(`Generating key for ${number}`);
    
    const digits = number.toString().split('').map(Number);
    const length = digits.length;
    const push = Array(12).fill(null).map((_, i) => {
      const digit = digits[i];
      return digit !== undefined ? `U${i + 1}:${digit}` : `U${i + 1}:null`;
    });
    
    const view = push.map(entry => {
      if (entry.includes('null')) return VOID_SYMBOL;
      const [, value] = entry.split(':');
      return SYMBOL_SEQUENCE[parseInt(value)] || VOID_SYMBOL;
    });
    
    const key = {
      number,
      length,
      push,
      view
    };
    
    console.log(`KEY:${number} LENGTH:${length} PUSH[${push.join(' ')}] VIEW:${view.join('|')}`);
    return key;
  }
}
------------------------------------------------------------------
shiftKey.js
------------------------------------------------------------------
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export default class ShiftKey {
  shift(key, targetLength) {
    console.log(`Shifting key for ${key.number} to targetLength: ${targetLength}`);
    
    const oldPush = key.push;
    console.log(`Shifting key: Old: PUSH[${oldPush.join(', ')}]`);
    
    // Default targetLength to key.length if undefined
    const effectiveTargetLength = targetLength !== undefined ? targetLength : key.length;
    if (targetLength === undefined) {
      console.warn(`Warning: targetLength undefined, defaulting to key.length=${key.length}`);
    }
    
    const newPush = Array(12).fill('null').map((_, i) => {
      const oldIndex = i - (effectiveTargetLength - key.length);
      if (oldIndex >= 0 && oldIndex < oldPush.length && !oldPush[oldIndex].includes('null')) {
        const [, value] = oldPush[oldIndex].split(':');
        return `U${i + 1}:${value}`; // Preserve value, update unit
      }
      return `U${i + 1}:null`;
    });
    
    const newView = newPush.map(entry => {
      if (entry.includes('null')) return VOID_SYMBOL;
      const [, value] = entry.split(':');
      return SYMBOL_SEQUENCE[parseInt(value)] || VOID_SYMBOL;
    });
    
    const shiftedKey = {
      number: key.number,
      length: key.length,
      targetLength: effectiveTargetLength,
      push: newPush,
      view: newView,
      targetUnit: `u${effectiveTargetLength}`
    };
    
    console.log(`Shifting key: New: PUSH[${newPush.join(', ')}]`);
    return shiftedKey;
  }
}
MorphLogic--------------------------------------------------------

------------------------------------------------------------------
PushModule.js
------------------------------------------------------------------
import { morphInit } from '../core/MorphInit.js';
import { SnapshotPush } from './SnapshotPush.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export default class PushModule {
  constructor(skeleton) {
    this.skeleton = skeleton;
  }

  async push(keyNumber) {
    console.log(`Applying push for ${keyNumber}`);
    
    const currentSkeletonNumber = parseInt(this.skeleton.units.slice(0, this.skeleton.state.numberLength).map(u => SYMBOL_SEQUENCE.indexOf(u.state.currentSymbol)).join('') || '0', 10);
    
    // Use MorphInit to determine skeleton and key
    const { skeleton, key } = await morphInit(keyNumber, currentSkeletonNumber, true);
    this.skeleton = skeleton;
    const units = this.skeleton.units;
    
    // Apply the shifted key for pushing
    for (let i = 0; i < key.push.length && i < units.length; i++) {
      const pushEntry = key.push[i];
      const [unitName, value] = pushEntry.split(':');
      const unitIndex = parseInt(unitName.replace('U', '')) - 1;
      const unit = units[unitIndex];
      const position = `u${unitIndex + 1}`;
      
      const currentSymbol = unit.state && unit.state.currentSymbol ? unit.state.currentSymbol : VOID_SYMBOL;
      
      if (value !== 'null') {
        const numValue = parseInt(value);
        if (numValue > 0) {
          console.log(`Pushing ${unitName}-${position}: ${numValue}`);
          unit.push(numValue, this.skeleton.carryBus);
          // Propagate carries
          while (this.skeleton.carryBus.carryValue > 0) {
            const { carryValue, carryTarget } = this.skeleton.carryBus.flushCarry();
            const targetIndex = parseInt(carryTarget.replace('Unit', '')) - 1;
            if (targetIndex >= 0 && targetIndex < units.length) {
              console.log(`Carry applied to Unit${targetIndex + 1}: ${carryValue}`);
              units[targetIndex].push(carryValue, this.skeleton.carryBus);
            }
          }
        } else if (currentSymbol !== VOID_SYMBOL) {
          console.log(`Preserving ${unitName}-${position}: ${currentSymbol} (no push)`);
        }
      } else {
        console.log(`Skipping ${unitName}-${position}: null`);
      }
    }
    
    // Check for U1 collapse and trigger snapPush if necessary
    const newSkeletonNumber = currentSkeletonNumber + keyNumber;
    await SnapshotPush.snapPush(this.skeleton, newSkeletonNumber);
    
    // Compute the new skeleton number for logging
    console.log(`Computed new skeleton number: ${newSkeletonNumber}`);
    
    // If snapPush didn't reset the skeleton (u1Collapse was false), reset it to the computed number
    const u1 = this.skeleton.units[0];
    if (!u1.state.u1Collapse) {
      console.log(`U1 did not collapse, resetting skeleton to computed number: ${newSkeletonNumber}`);
      const digits = newSkeletonNumber.toString().split('').map(Number);
      this.skeleton.state.numberLength = digits.length;
      this.skeleton.state.activeUnitTarget = `u${this.skeleton.state.numberLength}`;

      this.skeleton.units.forEach((unit, i) => {
        unit.state.currentSymbol = VOID_SYMBOL;
        unit.state.carry = 0;
        unit.state.hasCollapsed = false;
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
        unit.state.u1Collapse = false;

        const digit = digits[i];
        if (digit !== undefined) {
          console.log(`Resetting unit${i + 1} to ${digit}`);
          unit.state.currentSymbol = SYMBOL_SEQUENCE[digit];
          console.log(`Reset unit${i + 1} to ${digit} (symbol: ${SYMBOL_SEQUENCE[digit]})`);
        }
      });

      const state = this.skeleton.getState();
      this.skeleton.state.snapshot = JSON.parse(JSON.stringify(state)); // Deep copy snapshot
      const skeletonDisplay = `<${state.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${state.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${state.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
      console.log(`Snapshot: ${JSON.stringify({
        units: state.units.map(u => u.currentSymbol),
        numberLength: state.numberLength,
        activeUnitTarget: state.activeUnitTarget
      })}`);
      console.log(`Reset Skeleton: ${skeletonDisplay}`);
    }
    
    units.forEach(unit => {
      if (unit.state && unit.state.pushes) {
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
      }
    });
    
    const finalState = this.skeleton.getState();
    const skeletonDisplay = `<${finalState.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${finalState.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${finalState.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
    console.log(`Final Skeleton (after snapshot reset): ${skeletonDisplay}`);
    return finalState;
  }
}
------------------------------------------------------------------
PullModule.js
------------------------------------------------------------------
import { morphInit } from '../core/MorphInit.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export default class PullModule {
  constructor(skeleton) {
    this.skeleton = skeleton;
  }

  async pull(keyNumber) {
    console.log(`Applying pull for ${keyNumber}`);
    
    const currentSkeletonNumber = parseInt(this.skeleton.units.slice(0, this.skeleton.state.numberLength).map(u => SYMBOL_SEQUENCE.indexOf(u.state.currentSymbol)).join('') || '0', 10);
    
    // Use MorphInit to determine skeleton and key
    const { skeleton, key } = await morphInit(keyNumber, currentSkeletonNumber, false);
    this.skeleton = skeleton;
    const units = this.skeleton.units;
    
    // Apply the shifted key for pulling
    for (let i = 0; i < key.push.length && i < units.length; i++) {
      const pushEntry = key.push[i];
      const [unitName, value] = pushEntry.split(':');
      const unitIndex = parseInt(unitName.replace('U', '')) - 1;
      const unit = units[unitIndex];
      const position = `u${unitIndex + 1}`;
      
      const currentSymbol = unit.state && unit.state.currentSymbol ? unit.state.currentSymbol : VOID_SYMBOL;
      
      if (value !== 'null') {
        const numValue = parseInt(value);
        if (numValue > 0) {
          console.log(`Pulling ${unitName}-${position}: ${numValue}`);
          unit.pull(numValue, this.skeleton.carryBus);
          // Propagate borrows (negative carries)
          while (this.skeleton.carryBus.carryValue < 0) {
            const { carryValue, carryTarget } = this.skeleton.carryBus.flushCarry();
            const targetIndex = parseInt(carryTarget.replace('Unit', '')) - 1;
            if (targetIndex >= 0 && targetIndex < units.length) {
              console.log(`Borrow applied to Unit${targetIndex + 1}: ${carryValue}`);
              units[targetIndex].pull(1, this.skeleton.carryBus);
            }
          }
        } else if (currentSymbol !== VOID_SYMBOL) {
          console.log(`Preserving ${unitName}-${position}: ${currentSymbol} (no pull)`);
        }
      } else {
        console.log(`Skipping ${unitName}-${position}: null`);
      }
    }
    
    // Compute the new skeleton number for logging
    const newSkeletonNumber = Math.max(currentSkeletonNumber - keyNumber, 0);
    console.log(`Computed new skeleton number: ${newSkeletonNumber}`);
    
    // Reset the skeleton to the computed number
    console.log(`Resetting skeleton to computed number: ${newSkeletonNumber}`);
    const digits = newSkeletonNumber.toString().split('').map(Number);
    this.skeleton.state.numberLength = digits.length;
    this.skeleton.state.activeUnitTarget = `u${this.skeleton.state.numberLength}`;

    this.skeleton.units.forEach((unit, i) => {
      unit.state.currentSymbol = VOID_SYMBOL;
      unit.state.carry = 0;
      unit.state.hasCollapsed = false;
      unit.state.pushes = [];
      unit.state.pushesLength = 0;
      unit.state.u1Collapse = false;

      const digit = digits[i];
      if (digit !== undefined) {
        console.log(`Resetting unit${i + 1} to ${digit}`);
        unit.state.currentSymbol = SYMBOL_SEQUENCE[digit];
        console.log(`Reset unit${i + 1} to ${digit} (symbol: ${SYMBOL_SEQUENCE[digit]})`);
      }
    });

    const state = this.skeleton.getState();
    this.skeleton.state.snapshot = JSON.parse(JSON.stringify(state)); // Deep copy snapshot
    const skeletonDisplay = `<${state.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${state.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${state.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
    console.log(`Snapshot: ${JSON.stringify({
      units: state.units.map(u => u.currentSymbol),
      numberLength: state.numberLength,
      activeUnitTarget: state.activeUnitTarget
    })}`);
    console.log(`Reset Skeleton: ${skeletonDisplay}`);
    
    units.forEach(unit => {
      if (unit.state && unit.state.pushes) {
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
      }
    });
    
    const finalState = this.skeleton.getState();
    const finalSkeletonDisplay = `<${finalState.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${finalState.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${finalState.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
    console.log(`Final Skeleton (after pull): ${finalSkeletonDisplay}`);
    return finalState;
  }
}
------------------------------------------------------------------
SkeletonInitializer.js
------------------------------------------------------------------
import { extendUnits } from '../skeleton/unitExtensionsPush.js'; // Static import for debugging
import CarryBus from '../core/carryBus.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export default class SkeletonInitializer {
  constructor() {
    this.units = [];
    this.carryBus = null;
    this.state = {
      numberLength: 1,
      activeUnitTarget: 'u1',
      snapshot: null
    };
  }

  async init(isPushOperation = true) {
    try {
      // Temporarily using static import to debug
      console.log('Using static import for unitExtensionsPush.js');
      const { Unit1, Unit2, Unit3, Unit4, Unit5, Unit6, Unit7, Unit8, Unit9, Unit10, Unit11, Unit12 } = await extendUnits();
      
      this.units = [
        new Unit1(),
        new Unit2(),
        new Unit3(),
        new Unit4(),
        new Unit5(),
        new Unit6(),
        new Unit7(),
        new Unit8(),
        new Unit9(),
        new Unit10(),
        new Unit11(),
        new Unit12()
      ];
      this.carryBus = new CarryBus();
      this.units.forEach(unit => { unit.skeleton = this; });
    } catch (error) {
      console.error('Error in init:', error);
      throw error;
    }
  }

  async set(number, isPushOperation = true) {
    await this.init(isPushOperation);
    console.log(`Setting skeleton for ${number}`);
    
    if (number < 0 || number > 999999999999) {
      throw new Error('Number must be between 0 and 999,999,999,999');
    }
    
    const digits = number.toString().split('').map(Number);
    this.state.numberLength = digits.length;
    this.state.activeUnitTarget = `u${this.state.numberLength}`;
    
    this.units.forEach((unit, i) => {
      unit.state.currentSymbol = VOID_SYMBOL;
      unit.state.carry = 0;
      unit.state.hasCollapsed = false;
      unit.state.pushes = [];
      unit.state.pushesLength = 0;
      
      const digit = digits[i];
      if (digit !== undefined) {
        console.log(`Setting unit${i + 1} to ${digit}`);
        unit.state.currentSymbol = SYMBOL_SEQUENCE[digit];
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
        console.log(`Set unit${i + 1} to ${digit} (symbol: ${SYMBOL_SEQUENCE[digit]})`);
      }
    });
    
    const state = this.getState();
    this.state.snapshot = JSON.parse(JSON.stringify(state)); // Deep copy snapshot
    const skeleton = `<${state.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${state.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${state.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
    console.log(`Snapshot: ${JSON.stringify({
      units: state.units.map(u => u.currentSymbol),
      numberLength: state.numberLength,
      activeUnitTarget: state.activeUnitTarget
    })}`);
    console.log(`Skeleton: ${skeleton}`);
    return state;
  }

  getState() {
    return {
      units: this.units.map(unit => unit.getState()),
      numberLength: this.state.numberLength,
      activeUnitTarget: this.state.activeUnitTarget
    };
  }
}
------------------------------------------------------------------
SnapshotPull.js
------------------------------------------------------------------
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export const SnapshotPull = {
  async snapPull(skeleton, newNumber) {
    const u1 = skeleton.units[0]; // Unit 1

    // Check if U1 has collapsed (gone below 0)
    if (u1.state.u1Collapse) {
      console.log(`U1 has collapsed (u1Collapse: ${u1.state.u1Collapse}), triggering snapshot pull for new number: ${newNumber}`);

      // Snapshot the new number and reset the skeleton
      const digits = newNumber.toString().split('').map(Number);
      skeleton.state.numberLength = digits.length || 1; // Ensure length is at least 1 for 0
      skeleton.state.activeUnitTarget = `u${skeleton.state.numberLength}`;

      skeleton.units.forEach((unit, i) => {
        unit.state.currentSymbol = VOID_SYMBOL;
        unit.state.carry = 0;
        unit.state.hasCollapsed = false;
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
        unit.state.u1Collapse = false;

        const digit = digits[i];
        if (digit !== undefined) {
          console.log(`Resetting unit${i + 1} to ${digit}`);
          unit.state.currentSymbol = SYMBOL_SEQUENCE[digit];
          console.log(`Reset unit${i + 1} to ${digit} (symbol: ${SYMBOL_SEQUENCE[digit]})`);
        }
      });

      const state = skeleton.getState();
      skeleton.state.snapshot = JSON.parse(JSON.stringify(state)); // Deep copy snapshot
      const skeletonDisplay = `<${state.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${state.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${state.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
      console.log(`Snapshot: ${JSON.stringify({
        units: state.units.map(u => u.currentSymbol),
        numberLength: state.numberLength,
        activeUnitTarget: state.activeUnitTarget
      })}`);
      console.log(`Reset Skeleton: ${skeletonDisplay}`);
    } else {
      console.log(`U1 has not collapsed (u1Collapse: ${u1.state.u1Collapse}), skipping snapshot pull`);
    }

    return skeleton;
  }
};
------------------------------------------------------------------
SnapshotPush.js
------------------------------------------------------------------
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export const SnapshotPush = {
  async snapPush(skeleton, newNumber) {
    const u1 = skeleton.units[0]; // Unit 1

    // Check if U1 has collapsed (exceeded 9)
    if (u1.state.u1Collapse) {
      console.log(`U1 has collapsed (u1Collapse: ${u1.state.u1Collapse}), triggering snapshot push for new number: ${newNumber}`);

      // Snapshot the new number and reset the skeleton
      const digits = newNumber.toString().split('').map(Number);
      skeleton.state.numberLength = digits.length;
      skeleton.state.activeUnitTarget = `u${skeleton.state.numberLength}`;

      skeleton.units.forEach((unit, i) => {
        unit.state.currentSymbol = VOID_SYMBOL;
        unit.state.carry = 0;
        unit.state.hasCollapsed = false;
        unit.state.pushes = [];
        unit.state.pushesLength = 0;
        unit.state.u1Collapse = false;

        const digit = digits[i];
        if (digit !== undefined) {
          console.log(`Resetting unit${i + 1} to ${digit}`);
          unit.state.currentSymbol = SYMBOL_SEQUENCE[digit];
          console.log(`Reset unit${i + 1} to ${digit} (symbol: ${SYMBOL_SEQUENCE[digit]})`);
        }
      });

      const state = skeleton.getState();
      skeleton.state.snapshot = JSON.parse(JSON.stringify(state)); // Deep copy snapshot
      const skeletonDisplay = `<${state.units.slice(0, 4).map(u => u.currentSymbol).join('')}|${state.units.slice(4, 8).map(u => u.currentSymbol).join('')}|${state.units.slice(8, 12).map(u => u.currentSymbol).join('')}>`;
      console.log(`Snapshot: ${JSON.stringify({
        units: state.units.map(u => u.currentSymbol),
        numberLength: state.numberLength,
        activeUnitTarget: state.activeUnitTarget
      })}`);
      console.log(`Reset Skeleton: ${skeletonDisplay}`);
    } else {
      console.log(`U1 has not collapsed (u1Collapse: ${u1.state.u1Collapse}), skipping snapshot push`);
    }

    return skeleton;
  }
};


skeleton-------------------------------------------------
------------------------------------------------------------------
UNITS 1-12
------------------------------------------------------------------
import { VOID_SYMBOL } from '../core/SacredSymbols.js';
!Repeat for Rest
export class Unit1 {
  constructor() {
    this.unitNumber = 1;
    this.state = {
      currentSymbol: VOID_SYMBOL,
      carry: 0,
      hasCollapsed: false,
      pushes: [],
      pushesLength: 0,
      u1Collapse: false
    };
  }

  getState() {
    return this.state;
  }
}
------------------------------------------------------------------
unitExtensionsPull.js
------------------------------------------------------------------
import { Unit1 } from './unit1.js';
import { Unit2 } from './unit2.js';
import { Unit3 } from './unit3.js';
import { Unit4 } from './unit4.js';
import { Unit5 } from './unit5.js';
import { Unit6 } from './unit6.js';
import { Unit7 } from './unit7.js';
import { Unit8 } from './unit8.js';
import { Unit9 } from './unit9.js';
import { Unit10 } from './unit10.js';
import { Unit11 } from './unit11.js';
import { Unit12 } from './unit12.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export async function extendUnits() {
  class Unit1Pull extends Unit1 {
    pull(count, carryBus) {
      console.log(`unit1 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          this.state.u1Collapse = true;
          console.log(
            `unit1 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit1 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed} U1COLLAPSE: ${this.state.u1Collapse}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit1 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit1 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit2Pull extends Unit2 {
    pull(count, carryBus) {
      console.log(`unit2 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit2 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit2 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit2 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit2 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit3Pull extends Unit3 {
    pull(count, carryBus) {
      console.log(`unit3 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit3 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit3 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit3 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit3 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit4Pull extends Unit4 {
    pull(count, carryBus) {
      console.log(`unit4 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit4 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit4 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit4 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit4 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit5Pull extends Unit5 {
    pull(count, carryBus) {
      console.log(`unit5 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit5 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit5 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit5 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit5 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit6Pull extends Unit6 {
    pull(count, carryBus) {
      console.log(`unit6 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit6 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit6 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit6 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit6 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit7Pull extends Unit7 {
    pull(count, carryBus) {
      console.log(`unit7 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit7 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit7 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit7 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit7 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit8Pull extends Unit8 {
    pull(count, carryBus) {
      console.log(`unit8 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit8 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit8 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit8 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit8 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit9Pull extends Unit9 {
    pull(count, carryBus) {
      console.log(`unit9 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit9 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit9 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit9 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit9 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit10Pull extends Unit10 {
    pull(count, carryBus) {
      console.log(`unit10 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit10 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit10 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit10 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit10 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit11Pull extends Unit11 {
    pull(count, carryBus) {
      console.log(`unit11 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit11 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit11 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit11 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit11 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit12Pull extends Unit12 {
    pull(count, carryBus) {
      console.log(`unit12 Pull Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : 0;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex - 1);
        if (currentIndex < 0) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[10]; // Set to ♤ (10) temporarily
          this.state.carry = -1; // Register a borrow
          this.state.hasCollapsed = true;
          console.log(
            `unit12 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
          console.log(
            `unit12 Borrow: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          carryBus.registerCarry(this.state.carry, `Unit${this.unitNumber - 1}`);
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit12 Pull: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: -1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit12 Pull End: pushesLength=${this.state.pushesLength}`);
    }
  }

  return {
    Unit1: Unit1Pull,
    Unit2: Unit2Pull,
    Unit3: Unit3Pull,
    Unit4: Unit4Pull,
    Unit5: Unit5Pull,
    Unit6: Unit6Pull,
    Unit7: Unit7Pull,
    Unit8: Unit8Pull,
    Unit9: Unit9Pull,
    Unit10: Unit10Pull,
    Unit11: Unit11Pull,
    Unit12: Unit12Pull
  };
}
------------------------------------------------------------------
unitExtensionsPush.js
------------------------------------------------------------------
import { Unit1 } from './unit1.js';
import { Unit2 } from './unit2.js';
import { Unit3 } from './unit3.js';
import { Unit4 } from './unit4.js';
import { Unit5 } from './unit5.js';
import { Unit6 } from './unit6.js';
import { Unit7 } from './unit7.js';
import { Unit8 } from './unit8.js';
import { Unit9 } from './unit9.js';
import { Unit10 } from './unit10.js';
import { Unit11 } from './unit11.js';
import { Unit12 } from './unit12.js';
import { SYMBOL_SEQUENCE, VOID_SYMBOL } from '../core/SacredSymbols.js';

export async function extendUnits() {
  class Unit1Push extends Unit1 {
    push(count, carryBus) {
      console.log(`unit1 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          this.state.u1Collapse = true;
          console.log(
            `unit1 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit1 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed} U1COLLAPSE: ${this.state.u1Collapse}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit1 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit1 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit2Push extends Unit2 {
    push(count, carryBus) {
      console.log(`unit2 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit2 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit2 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit2 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit2 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit3Push extends Unit3 {
    push(count, carryBus) {
      console.log(`unit3 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit3 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit3 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit3 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit3 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit4Push extends Unit4 {
    push(count, carryBus) {
      console.log(`unit4 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit4 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit4 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit4 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit4 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit5Push extends Unit5 {
    push(count, carryBus) {
      console.log(`unit5 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit5 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit5 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit5 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit5 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit6Push extends Unit6 {
    push(count, carryBus) {
      console.log(`unit6 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit6 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit6 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit6 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit6 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit7Push extends Unit7 {
    push(count, carryBus) {
      console.log(`unit7 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit7 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit7 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit7 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit7 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit8Push extends Unit8 {
    push(count, carryBus) {
      console.log(`unit8 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit8 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit8 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit8 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit8 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit9Push extends Unit9 {
    push(count, carryBus) {
      console.log(`unit9 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit9 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit9 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit9 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit9 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit10Push extends Unit10 {
    push(count, carryBus) {
      console.log(`unit10 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit10 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit10 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit10 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit10 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit11Push extends Unit11 {
    push(count, carryBus) {
      console.log(`unit11 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit11 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit11 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit11 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit11 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  class Unit12Push extends Unit12 {
    push(count, carryBus) {
      console.log(`unit12 Push Start: times=${count}, currentSymbol=${this.state.currentSymbol}`);
      
      let currentIndex = this.state.currentSymbol && this.state.currentSymbol !== VOID_SYMBOL
        ? SYMBOL_SEQUENCE.indexOf(this.state.currentSymbol)
        : -1;
      
      for (let i = 0; i < count; i++) {
        currentIndex = (currentIndex + 1);
        if (currentIndex >= SYMBOL_SEQUENCE.length - 1) {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex]; // Set to ♤ temporarily
          this.state.carry = 1;
          this.state.hasCollapsed = true;
          console.log(
            `unit12 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
          console.log(
            `unit12 Carry: CARRY: ${this.state.carry} COLLAPSED: ${this.state.hasCollapsed}`
          );
          // Not propagating carry yet
        } else {
          this.state.currentSymbol = SYMBOL_SEQUENCE[currentIndex];
          console.log(
            `unit12 Push: SYMBOL: ${this.state.currentSymbol} CARRY: ${this.state.carry} DIRECTION: 1`
          );
        }
        this.state.pushes.push(this.state.currentSymbol);
      }
      
      this.state.pushesLength = this.state.pushes.length;
      console.log(`unit12 Push End: pushesLength=${this.state.pushesLength}`);
    }
  }

  return {
    Unit1: Unit1Push,
    Unit2: Unit2Push,
    Unit3: Unit3Push,
    Unit4: Unit4Push,
    Unit5: Unit5Push,
    Unit6: Unit6Push,
    Unit7: Unit7Push,
    Unit8: Unit8Push,
    Unit9: Unit9Push,
    Unit10: Unit10Push,
    Unit11: Unit11Push,
    Unit12: Unit12Push
  };
}


ZTRL//////////// NUEROM CONNECTION

send.js///////////////////////////
export function send(number) {
  // Validate the number
  if (typeof number !== 'number' || number < 0) {
    throw new Error('ZTRL send: Number must be a non-negative integer');
  }

  // Create Zeta-compatible object
  const zetaObject = {
    intent: 'PUSH',
    value: number
  };

  // Prepare the intent string for NUEROM
  const intentString = `${zetaObject.intent}[${zetaObject.value}]`;
  console.log(`ZTRL sending to NUEROM: ${intentString}`);

  return {
    morphCode: `MORPHCODE: Intent: ${zetaObject.intent}, value: ${zetaObject.value}`
  };
}